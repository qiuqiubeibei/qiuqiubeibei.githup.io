# 错误、异常和文件

## 1. 异常处理

***错误***指的是代码有语法问题，无法解释运行，必须改正后才能运行

如果代码没有语法问题，可以运行，但会出运行时的错误，例如除零错误，下标越界等问题，这种在运行期间检测到的错误被称为***异常*** ，出现了异常必须处理否则程序会终止执行，用户体验会很差。Phthon支持程序员自己处理检测到的异常。可以使用try-except语句进行异常的检测和处理

### 1.1 try-except语句

~~~
语法：
	try:
		【代码块A】 #可能会出错误的代码    异常检测
	except Exception1[ as e]:   #异常处理
	 【代码块1】  #异常处理代码       
    except Exception2[ as e]:   #异常处理
         【代码块2】  #异常处理代码
    ....
    except Exceptionn[ as e]:   #异常处理
      【代码块n】  #异常处理代码
	[else:]                #可选，如果没有引发异常会执行
	    处理语句       
	[finally:]             #无论如何都要执行的语句
	    处理语句
   【后续语句】
~~~

- 执行流程：
  - 1、首先执行try中【代码块A】，如果出现异常，立即终止代码执行，转而到except块中进行异常处理
  - 2、异常处理except模块可以多个，从上往下匹配，如果能够匹配成功，立即执行相应的异常处理代码块，执行完毕后，不在往下匹配，转到3执行
  - 3、执行异常处理完毕后，如果有finally字句则执行finally字句，如果没有则执行【后续语句】
  - 4、如果匹配不到异常，有finally则执行finally，然后则抛出错误，终止程序执行。
  - 5、如果没有异常，如果有else字句则执行else字句，执行完else后，有finally字句则执行，没有则执行【后续语句】
- 注意事项：
  - except匹配顺序从上到下
  - except语句书写要求：精确的类型往前放，模糊的，不精确的往后放
  - except不带任何类型，则匹配所有类型异常，应该放到最后，吞掉异常
  - 可以将多种异常用元组的方式（异常类型1，异常类型2...异常类型n）书写，简化代码
  - except字句中e，是一个对象，打印它，会显示异常信息描述
  - try-except也可以捕获方法或函数中抛出的异常
  - 所有异常类型都继承自BaseException，使用BaseException可以将异常一网打尽
  - finally字句中可以进行一些清理工作，比如关闭文件，数据库等工作

### 1.3 抛出异常

手动抛出一个指定类型的异常，无论是哪种异常类都可以带一个字符串参数，对异常进行描述。

- raise不带参数会把错误原样抛出

~~~
try:
    raise ZeroDivisionError('除0错误')
    # raise ZeroDivisionError  #如果不想获取错误信息，可以不带参数
except ZeroDivisionError as e:
    print(e)  #除0错误
~~~

### 1.4 异常嵌套

在try块和excep块中还可以分别再嵌套try-except块

### 1.5 assert断言

​    语法：assert 条件 [,异常描述字符串]

​     执行流程：如果条件为假，则抛出AssertionError，条件为真，就当assert不存在

​    作用：对于可能出问题的代码，加上断言，方便问题排查

~~~
print('start')
num = int(input('请输入一个1~9的整数:'))
assert 0 <num <=9,'num不在1~9'
print('end')
~~~

### 1.6 自定义异常类

如果系统异常类型满足不了业务需求，那么可以自己定义异常类来处理。

- 自己定义的异常类必须继承BaseException或Exception
- 步骤：
  - 在自定义异常类的构造函数中，调用父类构造函数
  - 重写`__str__`方法输出异常信息
  - 编写异常处理方法处理异常

~~~
class CustomError(BaseException): #继承BaseException
    def __init__(self,msg):
        super().__init__()  #调用父类初始化
        self.msg = msg
        
    #重写__str__，输出异常信息
    def __str__(self):
        return self.msg
    
    #3.自定义异常处理方法
    def handle_exception(self):
        print('异常处理')
        
try:
    raise CustomError('自定义异常')
except CustomError as e:
    print(e)
~~~



## 2. 文件处理

文件的处理包括读文件和写文件，读写文件就是请求操作系统打开一个文件对象，然后，通过操作系统提供的接口从这个文件对象中读取数据（读文件），或者把数据写入这个文件对象（写文件）。

### 2.1 文件读取

文件读取可分为以下步骤：

- 打开文件
- 读取文件内容
- 关闭文件

打开文件要使用open内建函数：

open(file [, mode='r',  encoding=None, errors=None]) 

参数说明： file：文件路径，可以是相对路径和绝对路径

​                    mode：文件打开模式

 		   encodeing: 文件编码方式，不用于二进制文件，一般是utf-8,gbk

​		    errors：指定如何处理编码和解码错误 ，适用于文本文件

返回值：一个可迭代的文件对象

| mode | 解释                                                         |
| ---- | ------------------------------------------------------------ |
| r    | 只读                                                         |
| w    | 只写，写之前会清空文件的内容，如果文件不存在，会创建新文件   |
| a    | 追加的方式，在原本内容中继续写，如果文件不存在，则会创建新文件 |
| r+   | 可读可写                                                     |
| w+   | 打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。 |
| a+   | 打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。 |
| b    | rb、wb、ab、rb+、wb+、ab+意义和上面一样，用于二进制文件操作  |

注意：二进制文件一般用于视频、音频、图片

读取文件常用函数：

| 函数             | 解释                                             |
| ---------------- | ------------------------------------------------ |
| read([size])     | 读取文件(读取size字符，默认读取全部)             |
| readline([size]) | 读取一行,如果指定size，将读入指定的字符数        |
| readlines()      | 把文件内容按行全部读入，返回一个包含所有行的列表 |

~~~
#打开文件
fp = open('qfile.txt','r',encoding='utf-8') 

#读取文件全部内容
#content = fp.read()  
#print(content)

#读取指定字符数,包括行尾的换行符\n
# print(fp.read(20))

#读取一行
# print(fp.readline(5))  #读取指定字符数
# print(fp.readline())  #读取一整行，直到碰到一个\n

#读取所有行，返回列表
# print(fp.readlines())  

#关闭文件
fp.close() 
~~~

~~~
#由于文件读写时都有可能产生IOError，一旦出错，后面的f.close()就不会调用。
# 所以，为了保证无论是否出错都能正确地关闭文件，我们可以使用try ... finally来实现：
# try:
#     fp = open('qfile.txt','r',encoding='utf-8')
#     print(fp.readlines())
# finally:
#     fp.close()
#可以简写为：
#with语句会自动调用close方法关闭文件
with open('qfile.txt','r',encoding='utf-8')  as fp:
    print(fp.readline())
~~~

~~~
#fread()和freadlines()会一次读入文件全部内容，如果文件太大，会直接耗尽内存的，因为文件对象可迭代，所以可以用for循环遍历文件读取
with open('qfile.txt','r',encoding='utf-8')  as fp:
    for line in fp:
        print(line.strip())   #注意无论是read、readline、readlines都会读入行末的\n，所以需要手动剔除\n
~~~

### 2.2 写文件

~~~
path = "file11.txt"

#1.打开文件
f = open(path,"w",encoding="utf-8")

#2.写入内容，将内容写入到缓冲区
#不会自动换行，需要换行的话，需要在字符串末尾添加换行符
f.write("Whatever is worth doing is worth doing well该行很骄傲很关键\n")


#3.刷新缓冲区【加速数据的流动，保证缓冲区的流畅】
f.flush()

#4.关闭文件  关闭文件也会刷新缓冲区
f.close()

#简写方式：可以不用手动调用close
with open(path,"w",encoding="utf-8") as f1:
    f.write("Whatever is worth doing is worth doing well该行很骄傲很关键")
~~~



### 2.3 移动文件指针

文件是顺序向后读写的，如果想要移动文件指针，可以使用seek方法：

file_obj.seek(offset,whence=0) 

功能：移动文件指针

参数：offset 是偏移量，正数表示从文件开头向文件末尾移动，负数相反。

​           whence ： 文件指针的位置，可选参数，值可以是

​                              SEEK_SET or 0   表示文件开头位置，是默认值

​                             SEEK_CUR or 1   表示当前位置（不能使用）

​                             SEEK_END or 2   文件末尾位置(不能使用)

返回值：无

~~~
#1.txt内容：hello world
with open('1.txt','r',encoding='utf-8') as fp:
    fp.seek(5)  #移动到hello后的空格位置
    print(fp.read(3))  #wo
    fp.seek(0)   #移动到开头
    print(fp.read(5))  #hello
    print(fp.tell())   #tell()显示当前指针位置
~~~

## 3.CSV文件操作

逗号分隔值（Comma-Separated Values，CSV），其文件以纯文本形式存储表格数据（数字和文本），文件的每一行都是一个数据记录。每个记录由一个或多个字段组成，用逗号分隔。使用逗号作为字段分隔符是此文件格式的名称的来源，因为分隔字符也可以不是逗号，有时也称为字符分隔值。

在Windows下，csv文件可以通过记事本，excel，notepad++,editplus等打开

- 作用：CSV广泛用于不同体系结构的应用程序之间交换数据表格信息，解决不兼容数据格式的互通问题。 
- 需要导入csv模块

### 3.1 读取csv

    import csv
    with open(r'csv\winequality-red.csv') as fp:  #1.打开文件
        #delimiter指定分隔符
        csv_reader = csv.reader(fp,delimiter=';')  #2.获取csv读取器
        header = next(csv_reader) #获取第一行的标题
        print(header)
        for line in csv_reader: #3.遍历所有的行
            print(line)

### 3.2 写入csv

    import csv
    l1 = [[1,2,3],[4,5,6],[7,8,9]]
    #打开文件时，要添加newline=''参数，否则会多一个空行
    with open('1.csv','w',newline='') as fp: #1.打开文件
    	#delimiter='\t'指定数据分隔符
        csv_writer = csv.writer(fp,delimiter='\t')  #2.获取writer
        for line in l1:
            csv_writer.writerow(line)  #3.写入文件

